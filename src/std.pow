;; [PowerText] Standard Library

[set _pi_ 3.141592653589793]

[def isnull [a]:
[= a null]]

[def iszero [a]:
[= a 0]]

[def isempty [a]:
[or [= a ""] [= a ()]]]

[def tolist [S]:
;; convert a string to a list
[set L ()]
[echo S "\n"]
[for [i 0 [1- [len S]]]:
[push L (S:i)]]
L]

[def ltostr [L]:
;; convert a list to a string
[? L:
[+ [tostr [head L]] [ltostr [tail L]]];
""]]

[def index [L item]:
;; get the index of an item in a list
[? [or [isnull L] [isnull item]]: null;
[set idx 0]
[set l L]
[while [!= l null]:
[? [!= [head l] item]:
[++ idx]
[set l [tail l]];
[exit]]]]
[? [isnull l]: null; idx]]

[def fact [n]:
  [def fact-tail [n prod]:
  [? [= n 0]: prod;
  [fact-tail [- n 1] [* n prod]]]]
[fact-tail n 1]]

[def sum [L]:
[? L:
[+ [head L] [sum [tail L]]];
0]]

[def count [item L]:
;; count occurrences of an item in a list
[? L: [+ [= item [head L]] [count item [tail L]]]; 0]]

[def in [a b]:
[? [not b]: false;
[? [= a [head b]]: true;
[in a [tail b]]]]]

[def abs [x]:
[? [>= x 0]: x; -x]]

[def range [a b]:
;; return a list of numbers
;; ranging from a to b
[set L ()]
[? [< a b]:
  [while [<= a b]:
  [push L a]
  [++ a]];
[while [>= a b]:
[push L a]
[-- a]]]
L]

[def steprange [a b c]:
;; return a list of numbers
;; ranging from a to b with a step of c
[set L ()]
[? [< a b]:
  [while [<= a b]:
  [push L a]
  [set a [+ a [abs c]]]];
[while [>= a b]:
[push L a]
[set a [- a [abs c]]]]]
L]

[def sort [L]:
;;sort list (in place)
[? [isempty L]: L;
[set m null]
[set q [1- [len L]]]
[for [i q 0 -1]:
[for [ii 0 i]:
[? [> (L:ii) (L:[1+ ii])]:
[set m (L:ii)]
[set (L:ii) (L:[1+ ii])]
[set (L:[1+ ii]) m]]]]
L]]

[def rndl [L]:
;; return randomized list
[? L:
[set new ()]
[set index [range 0 [1- [len L]]]]
[while [!= [len new] [len L]]:
[set i [rndr 0 [len index]]]
[push new (L:(index:i))]
[pop index i]]
new;
L]]

[def reverse [L]:
;; reverse order of a list (in place)
[? [isnull L]: null;
[set i 0]
[set j [1- [len L]]]
[while [< i j]:
[set a (L:i)] [set b (L:j)]
[set (L:j) a] [set (L:i) b]
[++ i] [-- j]]
L]]

[def max [L]:
[? [= [len L] 1]: [head L];
[set m1 [max [tail L]]]
[set m2 [head L]]
[? [> m1 m2]: m1; m2]]]

[def min [L]:
[? [= [len L] 1]: [head L];
[set m1 [min [tail L]]]
[set m2 [head L]]
[? [< m1 m2]: m1; m2]]]

[def get-value [L key]:
;; get the value of a given key
;; ((key1 value1) (key2 value2) ... (keyN valueN)) 
[? L:
[? [= key ([head L]:0)]: ([head L]:1); [get-value [tail L] key]];
null]]

[def get-pair [L key]:
[? L:
[? [= key ([head L]:0)]: [head L]; [get-pair [tail L] key]];
null]]

[def set-value [L key value]:
[? [= [type L] list]:
[? [set a [get-pair L key]]: [set (a:1) value];
[push L (key value)]];
null]]

[def rndr [a b]:
;; return an integer between a and b if a < b,
;; between b and a otherwise.
[set lo [? [< a b]: a; b]]
[set hi [? [> a b]: a; b]] 
[// [+ [* [rnd] hi] lo] 1]]

[def base [n b]:
;; convert n into base b
[? [or [< b 2] [> b 36]]: [echo "*** invalid base (2-36)"];
[? [= n 0]: "0";
[set digits (
"0" "1" "2" "3" "4" "5" "6" "7" "8" "9"
"A" "B" "C" "D" "E" "F" "G" "H" "I" "J"
"K" "L" "M" "N" "O" "P" "Q" "R" "S" "T"
"U" "V" "W" "X" "Y" "Z"
)]
[set result ""]
[while [> n 0]:
[set result [+ (digits:[% n b]) result]]
[set n [// n b]]]
result]]]

[def cls []:
;; clear the screen
[echo "\x1b[2J\x1b[H"]]

[def locate [y x]:
;; move cursor
[echo "\x1b[" y ";" x "H"]]

[def lecho [y x text]:
;; move cursor and print text
[locate y x]
[echo text]]

[def clrline [y x]:
;; clear a line
[locate y x]
[echo "\x1b[K"]]

[def hidecursor []:
[echo "\x1b[?25l"]]

[def showcursor []:
[echo "\x1b[?25h"]]

[def scrh []:
;; screen height
[set s [scrsize]]
(s:0)]

[def scrw []:
;; screen width
[set s [scrsize]]
(s:1)]

[def cury []:
;; cursor y position
[set yx [getcur]]
(yx:0)]

[def curx []:
;; cursor x location
[set yx [getcur]]
(yx:1)]

